# 解题思路

## Step1. 定义子问题，确定状态
动态规划本质上是将一个大问题逐步缩小规模

用leetcode 150题中的5个dp为例：

1. 打家劫舍： 原问题「从全部房子中能偷到的最大金额」 => 子问题「从前k个房子能偷到的最大金额」
2. 单词拆分：   原问题「字符串s能否全部由wordList中的单词组成」=> 子问题「前k个字符否全部由wordList中的单词组成」
3. 硬币兑换： 原问题「给定一个整数amount，能否由指定面值的硬币组成」 => 子问题「1元、2元....acount元能否由制定面值的硬币组成」
4. 最长递增子序列：  原问题「求某个数组的最长递增子序列」 => 子问题「数组中前k个元素的最长递增子序列」
5. 爬楼梯：  原问题「爬n阶台阶有多少种方法」 => 子问题「爬1阶、2阶....n阶台阶有多少种方法」

总上面的例子可以看出，拆解子问题的关键是在保证<u>问题不变</u>的情况下，缩小问题的规模。如果是int或String，先把他们转成一个List （即dp数组），然后再把问题转化成前k个元素+原问题的子问题。

注：关于dp数组的长度是length+1还是length，这个要取决于我们的问题对象是不是数组，比如子序列、打家劫舍，给到的就是数组对象，那么dp\[i\]所代表的数据就是子问题的解,所以dp数组的长度也和length保持一致。
但是比如爬楼梯、零钱兑换等问题，是int或者string转的，当dp数组长度仍然为n时，dp\[i\]的含义就不对了（比如<u>爬楼梯的dp\[i-1\]表示的却是爬第i个台阶的方法数</u>，这样就很奇怪）。所以需要给一个dp\[0\]的初始值，保证dp\[i\]的含义正确。



## Step2. 转移方程
转移方程是dp问题最关键的一步，需要给出问题的递推关系，如果给不出那么就无法使用动态规划解题。

还是用上面的5个例子：
1. 打家劫舍：一共有n个房子，每个房子的金额分别为H<sub>0</sub> H<sub>1</sub> ... H<sub>n-1</sub>  子问题f(k)表示「从前k个房子能偷到的最大金额」。偷k个房子有两种方法：1）偷第k-1房子，不偷k间房
  2）偷第k-2和第k房子，也就是如果要解决前k个房子问题，需要分别解出k-1,k-2房子的问题，将问题进一步缩小，并得到递推公式：
    
    ```  
    dp[k] = max{ dp[k−1],dp[k-2]+H[k] }
    
    k=0,1...,n-1
    ```
2. 单词拆分：
    ```
    dp[i] = dp[j] && check(s[j..i−1])
    
    其中 i = check(s[j..i−1]) 表示子串 s[j..i−1] 是否出现在字典中。
    ```
3. 兑换硬币：
    ```
    dp[i] =  min(dp[n-c1],dp[n-c2]...,dp[n-cn]) +1
    
    其中c1,c2,...cn是给定的面值
    ```
4. 最长递增子序列： 
    ```
    dp[i] = max(dp[c1],dp[c2],dp[c3]...) + 1  
    
    其中nums[c1]<nums[i]
    
    ```

5. 爬楼梯
    ```
    dp[i] = dp[i-1]+dp[i-2]
    ```
    
注：<u>这里要注意单词拆分、硬币兑换、最长递增子序列这种的递推关系，也就是dp\[k\]并不是和固定位置的dp结果有关联，而是需要动态计算的。</u>

## Step3. 设置初始状态

如果f(k)依赖f(k-1) f(k-2)，那么我们需要手动定义k=1,k=0的情况，避免越界

## Step4. 控件优化
空间优化的场景：很多时候我们并不需要始终持有全部的 DP 数组。比如打家劫舍问题，我们发现，最后一步计算 f(n) 的时候，实际上只用到了 f(n−1) 和 f(n−2） 的结果。n−3 之前的子问题，实际上早就已经用不到了。那么，我们可以只用两个变量保存两个子问题的结果，就可以依次计算出所有的子问题。


## Step4. 设置返回值

依照我们对dp的定义，看看是返回dp\[length-1\]，还是dp数组中的最大最小值